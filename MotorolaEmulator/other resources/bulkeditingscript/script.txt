#include "mainwindow.h"
#include "instructionblock.h"
#include "ui_mainwindow.h"
#include "./ui_mainwindow.h"
#include <QStringBuilder>
#include <QScrollBar>
#include <iostream>
#include <map>
#include <iomanip>
#include <sstream>
#include <QTextBlock>

MainWindow::MainWindow(QWidget* parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    updateMemoryTab();
    connect(ui->plainTextCode->verticalScrollBar(), &QScrollBar::valueChanged, this, &MainWindow::handleVerticalScrollBarValueChanged);
    connect(this, &MainWindow::resized, this, &MainWindow::handleMainWindowSizeChanged);
}
MainWindow::~MainWindow()
{
    delete ui;
}

std::unordered_map<int, int> lineMemMap;
std::unordered_map<QString, int> labelValMap;
std::unordered_map<int, QString> callLabelMap;
std::unordered_map<int, QString> callLabelRelMap;
std::unordered_map<int, QString> callLabelRazMap;

int currentLine;
int currentAddress;
QByteArray Memory = QByteArray(0xFFFF, '\0');
QStringList specialInstructions = { "" };

QStringList allInstructions = { "ABA", "ABX", "ADCA", "ADCB", "ADDA", "ADDB", "ADDD", "ANDA", "ANDB", "ASL", "ASLA", "ASLB", "ASLD", "ASR", "ASRA", "ASRB", "BCC", "BCS", "BEQ", "BGE", "BGT", "BHI", "BHS", "BITA", "BITB", "BLE", "BLO", "BLS", "BLT", "BMI", "BNE", "BPL", "BRA", "BRN", "BSR", "BVC", "BVS", "CBA", "CLC", "CLI", "CLR", "CLRA", "CLRB", "CLV", "CMPA", "CMPB", "COM", "COMA", "COMB", "CPX", "DAA", "DEC", "DECA", "DECB", "DES", "DEX", "EORA", "EORB", "INC", "INCA", "INCB", "INS", "INX", "JMP", "JSR", "LDAA", "LDAB", "LDD", "LDS", "LDX", "LSL", "LSLA", "LSLB", "LSLD", "LSR", "LSRA", "LSRB", "LSRD", "MUL", "NEG", "NEGA", "NEGB", "NOP", "ORAA", "ORAB", "PSHA", "PSHB", "PSHX", "PULA", "PULB", "PULX", "ROL", "ROLA", "ROLB", "ROR", "RORA", "RORB", "RTI", "RTS", "SBA", "SBCA", "SBCB", "SEC", "SEI", "SEV", "STAA", "STAB", "STD", "STS", "STX", "SUBA", "SUBB", "SUBD", "SWI", "TAB", "TAP", "TBA", "TPA", "TST", "TSTA", "TSTB", "TSX", "TXS", "WAI", !inALL };
QStringList vseInstructions = { "ABA", "ABX", "ASLA", "ASLB", "ASLD", "ASRA", "ASRB", "CBA", "CLC", "CLI", "CLRA", "CLRB", "CLV", "COMA", "COMB", "DAA", "DECA", "DECB", "INCA", "INCB", "INS", "INX", "LSLA", "LSLB", "LSLD", "LSRA", "LSRB", "LSRD", "MUL", "NEGA", "NEGB", "NOP", "PSHA", "PSHB", "PSHX", "PULA", "PULB", "PULX", "ROLA", "ROLB", "RORA", "RORB", "RTI", "RTS", "SBA", "SEC", "SEI", "SEV", "SWI", "TAB", "TAP", "TBA", "TPA", "TSTA", "TSTB", "TSX", "TXS", "WAI", !inVSE };
QStringList takInstructions = { "ADCA", "ADCB", "ADDA", "ADDB", "ANDA", "ANDB", "BITA", "BITB", "CMPA", "CMPB", "EORA", "EORB", "LDAA", "LDAB", "ORAA", "ORAB", "SBCA", "SBCB", "SUBA", "SUBB", "SUBD", !inTAKO };
QStringList takRazInstructions = { "ADDD", "CPX", "LDD", "LDS", "LDX", !inTAKRAZ };
QStringList dirInstructions = { "ADCA", "ADCB", "ADDA", "ADDB", "ADDD", "ANDA", "ANDB", "BITA", "BITB", "CMPA", "CMPB", "CPX", "EORA", "EORB", "JSR", "LDAA", "LDAB", "LDD", "LDS", "LDX", "ORAA", "ORAB", "SBCA", "SBCB", "STAA", "STAB", "STD", "STS", "STX", "SUBA", "SUBB", "SUBD", !inDIR };
QStringList razInstructions = { "ADCA", "ADCB", "ADDA", "ADDB", "ADDD", "ANDA", "ANDB", "ASL", "ASR", "BITA", "BITB", "CLR", "CMPA", "CMPB", "COM", "CPX", "DEC", "DES", "DEX", "EORA", "EORB", "INC", "JMP", "JSR", "LDAA", "LDAB", "LDD", "LDS", "LDX", "LSL", "LSR", "NEG", "ORAA", "ORAB", "ROL", "ROR", "SBCA", "SBCB", "STAA", "STAB", "STD", "STS", "STX", "SUBA", "SUBB", "SUBD", "TST", !inRAZ };
QStringList indInstructions = { "ADCA", "ADCB", "ADDA", "ADDB", "ADDD", "ANDA", "ANDB", "ASL", "ASR", "BITA", "BITB", "CLR", "CMPA", "CMPB", "COM", "CPX", "DEC", "EORA", "EORB", "INC", "JMP", "JSR", "LDAA", "LDAB", "LDD", "LDS", "LDX", "LSL", "LSR", "NEG", "ORAA", "ORAB", "ROL", "ROR", "SBCA", "SBCB", "STAA", "STAB", "STD", "STS", "STX", "SUBA", "SUBB", "SUBD", "TST", !inIND };
QStringList relInstructions = { "BCC", "BCS", "BEQ", "BGE", "BGT", "BHI", "BHS", "BLE", "BLO", "BLS", "BLT", "BMI", "BNE", "BPL", "BRA", "BRN", "BSR", "BVC", "BVS", !inREL };


QString convertToQString(int number, int width)
{
    std::stringstream stream;
    stream << std::setfill('0') << std::setw(width) << number;
    std::string str = stream.str();
    return QString::fromStdString(str);
}
void MainWindow::updateMemoryTab()
{
    const int memorySize = Memory.size();
    const int lineSize = 16;
    QString text;
    text.reserve((memorySize / lineSize) * (lineSize * 3 + 12)); // Preallocate memory for the final string
    text += "      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n";
    for (int i = 0; i < memorySize; i++) {
        if (i % lineSize == 0) {
            text += QString("%1: ").arg(i, 4, 16, QChar('0'));
        }
        text += QString("%1 ").arg((quint8)Memory.at(i), 2, 16, QChar('0'));
        if (i % lineSize == lineSize - 1) {
            text += '\n';
        }
    }
    ui->plainTextMemory->setPlainText(text);
}

void MainWindow::handleVerticalScrollBarValueChanged(int value)
{
    ui->plainTextLines->verticalScrollBar()->setValue(value);
}
void MainWindow::resizeEvent(QResizeEvent* event)
{
    QMainWindow::resizeEvent(event);
    emit resized(this->size());
}
void MainWindow::handleMainWindowSizeChanged(const QSize& newSize)
{
    if (newSize.width() >= 1785) {
        ui->plainTextDisplay->setGeometry(0, 0, 498, 350);
        ui->plainTextDisplay->setEnabled(true);
        ui->frameDisplay->setGeometry(910, 10, 498, 350);
        ui->frameDisplay->setEnabled(true);
        if (newSize.height() >= 800) {
            ui->tabWidget->setGeometry(910, 370, newSize.width() - 915, newSize.height() - 432);
        }
        else {
            ui->tabWidget->setGeometry(newSize.width() - 370, 300, 361, newSize.height() - 358);
        }
    }
    else {
        ui->plainTextDisplay->setGeometry(0, 0, 0, 0);
        ui->plainTextDisplay->setEnabled(false);
        ui->frameDisplay->setGeometry(910, 10, 0, 0);
        ui->frameDisplay->setEnabled(false);

        ui->tabWidget->setGeometry(910, 300, newSize.width() - 917, newSize.height() - 358);
    }
    qDebug() << "New main window size:" << newSize;
    int buttonY = newSize.height() - 50;

    ui->buttonCompile->setGeometry(ui->buttonCompile->x(), buttonY, ui->buttonCompile->width(), ui->buttonCompile->height());
    ui->buttonLoad->setGeometry(ui->buttonLoad->x(), buttonY, ui->buttonLoad->width(), ui->buttonLoad->height());
    ui->buttonSave->setGeometry(ui->buttonSave->x(), buttonY, ui->buttonSave->width(), ui->buttonSave->height());
    ui->buttonReset->setGeometry(ui->buttonReset->x(), buttonY, ui->buttonReset->width(), ui->buttonReset->height());
    ui->buttonStep->setGeometry(ui->buttonStep->x(), buttonY, ui->buttonStep->width(), ui->buttonStep->height());
    ui->buttonRunStop->setGeometry(ui->buttonRunStop->x(), buttonY, ui->buttonRunStop->width(), ui->buttonRunStop->height());
    ui->comboBoxSpeedSelector->setGeometry(ui->comboBoxSpeedSelector->x(), buttonY, ui->comboBoxSpeedSelector->width(), ui->comboBoxSpeedSelector->height());
    ui->plainTextCode->setGeometry(ui->plainTextCode->x(), ui->plainTextCode->y(), ui->plainTextCode->width(), newSize.height() - 69);
    ui->plainTextLines->setGeometry(ui->plainTextLines->x(), ui->plainTextLines->y(), ui->plainTextLines->width(), newSize.height() - 69);
    ui->plainTextMemory->setGeometry(ui->plainTextMemory->x(), ui->plainTextMemory->y(), ui->plainTextMemory->width(), newSize.height() - 69);
    ui->groupBox->setGeometry(newSize.width() - 370, ui->groupBox->y(), ui->groupBox->width(), ui->groupBox->height());
    ui->plainTextConsole->setGeometry(5, 5, ui->tabWidget->width() - 15, ui->tabWidget->height() - 35);
}

int getNumber()
{
    return 0;
}
int getNum(const QString& input)
{
    bool ok;
    int number;
    if (input.startsWith('$')) {
        QString hexValue = input.mid(1);
        number = hexValue.toUInt(&ok, 16);
        if (!ok) {
            throw std::invalid_argument("Invalid hexadecimal number: " + input.toStdString());
        }
    }
    else if (input.startsWith('%')) {
        QString binaryValue = input.mid(1);
        number = binaryValue.toUInt(&ok, 2);
        if (!ok) {
            throw std::invalid_argument("Invalid binary number: " + input.toStdString());
        }
    }
    else {
        number = input.toUInt(&ok);
        if (!ok) {
            throw std::invalid_argument("Invalid decimal number: " + input.toStdString());
        }
    }
    return number;
}

void MainWindow::PrintConsole(const QString& text, int type)
{
    QString consoleText;
    if (type == -1) { // DEBUG
        consoleText = "DEBUG: " + ("Ln:" + QString::number(currentLine)) + " " + text;
    }
    else if (type == 0 && ui->checkBoxError->isChecked()) { // ERROR
        consoleText = "ERROR: " + text;
    }
    else if (type == 1 && ui->checkBoxWarn->isChecked()) { //WARN
        consoleText = "WARN: " + text;
    }
    else {
        consoleText = text;
    }
    ui->plainTextConsole->setPlainText(ui->plainTextConsole->toPlainText() + "\n" + consoleText);
}
void MainWindow::Err(const QString& text)
{
    QString message = "Ln:" + QString::number(currentLine) + " " + text;
    PrintConsole(message, 0);
}

void MainWindow::on_plainTextCode_textChanged()
{
    ui->plainTextCode->setExtraSelections(QList<QTextEdit::ExtraSelection>());
    ui->plainTextLines->setExtraSelections(QList<QTextEdit::ExtraSelection>());
    lineMemMap.clear();
    QString code = ui->plainTextCode->toPlainText();
    int lineCount = code.count('\n') + 1;
    QString text;
    for (int i = 0; i < lineCount; i++) {
        text = text % convertToQString(i, 4) % QString(":0000") % "\n";
    }
    ui->plainTextLines->setPlainText(text);
    ui->plainTextLines->verticalScrollBar()->setValue(ui->plainTextCode->verticalScrollBar()->value());
}
void MainWindow::on_buttonCompile_clicked()
{
    PrintConsole("", 2);
    currentLine = 0;
    currentAddress = 0;
    Memory.fill(0);
    labelValMap.clear();
    callLabelMap.clear();
    QString code = ui->plainTextCode->toPlainText();
    QStringList lines = code.split("\n");
    int charNum = 0;
    foreach (QString line, lines) {
        QString label;
        QString in;
        QString op;
        int inCode = 0;
        int opCode = 0;
        bool operandCallsLabel = false;
        if (line.contains(";")) {
            line = line.split(";")[0];
            for (int var = line.length(); var > 0; --var) {
                if (line.endsWith(' ')){
                    line.chop(1);
                } else{
                    break;
                }
            }
        }
    labelExtraction:
        if (line.isEmpty()) {
            PrintConsole("Empty line", -1);
            continue;
        }
        else if (line[0].isLetter()) {
            //extract lable
            charNum++;
            for (; charNum < line.size(); ++charNum) {
                if (line[charNum].isLetterOrNumber() || line[charNum] == '_') {
                    if (charNum == line.size() - 1) {
                        Err("Missing instruction");
                        goto end;
                    }
                }
                else if (line[charNum] == '\t') {
                    label = line.mid(0, charNum);
                    charNum++;
                    goto lineDisection;
                }
                else if (line[charNum] == ' ') {
                    Err("Label cannot contain a space and must be followed by a tab");
                    goto end;
                }
                else {
                    Err("Unexpected character: '" % line[charNum] % "'");
                    goto end;
                }
            }
        }
        else if (line[0] == '\t') {
            //no label
            charNum++;
        }
        else {
            Err("Line cannot start with: '" % line[0] % "'");
            goto end;
        }
    lineDisection:
        if (line.mid(charNum).isEmpty()) {
            Err("Missing instruction");
            goto end;
        }
        else if (line[charNum].isLetter() || line[charNum] == '.') {
            charNum++;
            if (line.mid(charNum).isEmpty()) {
                Err("Missing instruction");
                goto end;
            }
            for (int start = charNum; charNum < line.size(); ++charNum) {
                if (line[charNum].isLetter()) {
                    if (charNum == line.size() - 1) {
                        in = line.mid(start).toUpper();
                        goto operationIdentification;
                    }
                }
                else if (line[charNum] == ' ') {
                    in = (line.mid(start, charNum - start)).toUpper();
                    charNum++;
                    break;
                }
                else {
                    Err("Unexpected character: '" % line[charNum] % "'");
                    goto end;
                }
            }
            if (line.mid(charNum).isEmpty()) {
                charNum--;
                Err("Unexpected space or missing operand");
                goto end;
            }
            op = line.mid(charNum);
            if (line[charNum] == '#') {
                if (op.contains(",")) {
                    Err("Cannot mix immediate and indexed");
                    goto end;
                }
                charNum++;
                if (line.mid(charNum).isEmpty()) {
                    charNum--;
                    Err("Invalid operand");
                    goto end;
                }
                if (line[charNum].isLetter()) {
                    operandCallsLabel = true;
                    charNum++;
                    for (; charNum < line.size(); ++charNum) {
                        if (line[charNum].isLetterOrNumber() || line[charNum] == '_') {
                        }
                        else {
                            Err("Unexpected character: '" % line[charNum] % "'");
                            goto end;
                        }
                    }
                }
                else if (line[charNum] == '%' || line[charNum] == '-' || line[charNum].isDigit()) {
                    charNum++;
                    for (; charNum < line.size(); ++charNum) {
                        if (line[charNum].isDigit()) {
                        }
                        else {
                            Err("Unexpected character: '" % line[charNum] % "'");
                            goto end;
                        }
                    }
                }
                else if (line[charNum] == '$') {
                    charNum++;
                    if (line.mid(charNum).isEmpty()) {
                        Err("Missing operand");
                        goto end;
                    }
                    for (; charNum < line.size(); ++charNum) {
                        if (line[charNum].isDigit()) {
                        }
                        else {
                            Err("Unexpected character: '" % line[charNum] % "'");
                            goto end;
                        }
                    }
                }
                else {
                    Err("Unexpected character: '" % line[charNum] % "'");
                    goto end;
                }
            }
            else if (line[charNum].isLetter()) {
                operandCallsLabel = true;
                charNum++;
                for (; charNum < line.size(); ++charNum) {
                    if (line.size() - 2 == charNum) {
                        if (line[charNum] == ',') {
                            if (line[charNum + 1].toUpper() == 'X') {
                                charNum++;
                                break;
                            }
                            else {
                                Err("Invalid indexing register");
                                charNum++;
                                goto end;
                            }
                        }
                    }
                    else if (line[charNum].isLetterOrNumber() || line[charNum] == '_') {
                    }
                    else {
                        Err("Unexpected character: '" % line[charNum] % "'");
                        goto end;
                    }
                }
            }
            else if (line[charNum] == '%' || line[charNum] == '-' || line[charNum].isDigit()) {
                charNum++;
                for (; charNum < line.size(); ++charNum) {
                    if (line.size() - 2 == charNum) {
                        if (line[charNum] == ',') {
                            if (line[charNum + 1].toUpper() == 'X') {
                                charNum++;
                                break;
                            }
                            else {
                                Err("Invalid indexing register");
                                goto end;
                            }
                        }
                    }
                    else if (line[charNum].isDigit()) {
                    }
                    else {
                        Err("Unexpected character: '" % line[charNum] % "'");
                        goto end;
                    }
                }
            }
            else if (line[charNum] == '$') {
                charNum++;
                if (line.mid(charNum).isEmpty()) {
                    Err("Missing operand");
                    goto end;
                }
                for (; charNum < line.size(); ++charNum) {
                    if (line.size() - 2 == charNum) {
                        if (line[charNum] == ',') {
                            if (line[charNum + 1].toUpper() == 'X') {
                                charNum++;
                                break;
                            }
                            else {
                                Err("Invalid indexing register");
                                goto end;
                            }
                        }
                    }
                    else if (line[charNum].isDigit()) {
                    }
                    else {
                        Err("Unexpected character: '" % line[charNum] % "'");
                        goto end;
                    }
                }
            }
            else {
                Err("unexpected character: '" % line[charNum] % "'");
                goto end;
            }
        }
        else {
            Err("Unexpected character: '" % line[charNum] % "'");
            goto end;
        }
    operationIdentification:
        charNum = 1000;
        //if (allInstructions.indexOf(in) == -1 && specialInstructions.indexOf(in) == -1) {
        //    Err("Unknown instruction");
        //    goto end;
        //}
        if (in[0] == '.') {
            if(in == ".BYTE"){
                if (label == "") {
                    Err("Missing label");
                    goto end;
                }
                else if (op == "") {
                    Err("Missing operand");
                    goto end;
                }
                else {
                    if(op[0].isLetter()){
                        Err("Cannot use label in this directive"); goto end;
                    } else{
                        int value = 0; try {int value = getNum(op);} catch (...) { Err("Invalid number: " + op); goto end; }
                        if(value > 255){Err("Value out of range: " + QString::number(value)); goto end;}
                        Memory[currentAddress] = value;
                        if(labelValMap.count(label) == 0){labelValMap[label] = currentAddress;} else{Err("Label already declared: '" + label + "'"); goto end;}
                        currentAddress++;
                        goto skipLine;
                    }
                }
            } else{
                Err("Unknown instruction");
                goto end;
            }

        }
        else if (in == "EQU") {
            if (label == "") {
                Err("Missing label");
                goto end;
            }
            else if (op == "") {
                Err("Missing operand");
                goto end;
            }
            else {
                if(op[0].isLetter()){
                    Err("Cannot use label in this directive"); goto end;
                } else{
                    int value = 0; try {int value = getNum(op);} catch (...) { Err("Invalid number: " + op); goto end; }
                    if(value > 0xFFFF){Err("Value out of range: " + QString::number(value)); goto end;}
                    if(labelValMap.count(label) == 0){labelValMap[label] = value;} else{Err("Label already declared: '" + label + "'"); goto end;}
                    goto skipLine;
                }
            }
        }
        else if (vseInstructions.indexOf(in) != -1) { //VSE
            if (op != "") {
                Err("Unexpected operand");
                goto end;
            }
	    if (in == "ABA") {
    inCode = 0x1B;
} else if (in == "ABX") {
    inCode = 0x3A;
} else if (in == "ASLA") {
    inCode = 0x48;
} else if (in == "ASLB") {
    inCode = 0x58;
} else if (in == "ASLD") {
    inCode = 0x05;
} else if (in == "ASRA") {
    inCode = 0x47;
} else if (in == "ASRB") {
    inCode = 0x57;
} else if (in == "CBA") {
    inCode = 0x11;
} else if (in == "CLC") {
    inCode = 0x0C;
} else if (in == "CLI") {
    inCode = 0x0E;
} else if (in == "CLRA") {
    inCode = 0x4F;
} else if (in == "CLRB") {
    inCode = 0x0F;
} else if (in == "CLV") {
    inCode = 0x0A;
} else if (in == "COMA") {
    inCode = 0x43;
} else if (in == "COMB") {
    inCode = 0x53;
} else if (in == "DAA") {
    inCode = 0x19;
} else if (in == "DECA") {
    inCode = 0x4A;
} else if (in == "DECB") {
    inCode = 0x5A;
} else if (in == "INCA") {
    inCode = 0x4C;
} else if (in == "INCB") {
    inCode = 0x5C;
} else if (in == "INS") {
    inCode = 0x31;
} else if (in == "INX") {
    inCode = 0x08;
} else if (in == "LSLA") {
    inCode = 0x48;
} else if (in == "LSLB") {
    inCode = 0x58;
} else if (in == "LSLD") {
    inCode = 0x05;
} else if (in == "LSRA") {
    inCode = 0x44;
} else if (in == "LSRB") {
    inCode = 0x54;
} else if (in == "LSRD") {
    inCode = 0x04;
} else if (in == "MUL") {
    inCode = 0x3D;
} else if (in == "NEGA") {
    inCode = 0x40;
} else if (in == "NEGB") {
    inCode = 0x50;
} else if (in == "NOP") {
    inCode = 0x01;
} else if (in == "PSHA") {
    inCode = 0x36;
} else if (in == "PSHB") {
    inCode = 0x37;
} else if (in == "PSHX") {
    inCode = 0x3C;
} else if (in == "PULA") {
    inCode = 0x32;
} else if (in == "PULB") {
    inCode = 0x33;
} else if (in == "PULX") {
    inCode = 0x38;
} else if (in == "ROLA") {
    inCode = 0x49;
} else if (in == "ROLB") {
    inCode = 0x59;
} else if (in == "RORA") {
    inCode = 0x46;
} else if (in == "RORB") {
    inCode = 0x56;
} else if (in == "RTI") {
    inCode = 0x3B;
} else if (in == "RTS") {
    inCode = 0x39;
} else if (in == "SBA") {
    inCode = 0x10;
} else if (in == "SEC") {
    inCode = 0x0D;
} else if (in == "SEI") {
    inCode = 0x0F;
} else if (in == "SEV") {
    inCode = 0x0B;
} else if (in == "SWI") {
    inCode = 0x3F;
} else if (in == "TAB") {
    inCode = 0x16;
} else if (in == "TAP") {
    inCode = 0x06;
} else if (in == "TBA") {
    inCode = 0x17;
} else if (in == "TPA") {
    inCode = 0x07;
} else if (in == "TSTA") {
    inCode = 0x4D;
} else if (in == "TSTB") {
    inCode = 0x5D;
} else if (in == "TSX") {
    inCode = 0x30;
} else if (in == "TXS") {
    inCode = 0x35;
} else if (in == "WAI") {
    inCode = 0x3E;
} else !opVSE
            else {
                Err("Unknown instruction");
                goto end;
            }
            if (!label.isEmpty()){
                if(labelValMap.count(label) == 0){labelValMap[label] = currentAddress;} else{Err("Label already declared: '" + label + "'"); goto end;}
            }
            Memory[currentAddress] = inCode;
            addInstruction(currentAddress, in, op, inCode, opCode);
            currentAddress += 1;
            goto skipLine;
        }
        else {
            if (op.isEmpty()) {
                Err("Missing operand");
                goto end;
            }
            if (!label.isEmpty()){
                if(labelValMap.count(label) == 0){labelValMap[label] = currentAddress;} else{Err("Label already declared: '" + label + "'"); goto end;}
            }
        }
        if (relInstructions.indexOf(in) != -1) { //REL
            if (op.startsWith("#")) {
                Err("Instruction won't take immediate data");
                goto end;
            }
            if (in == "BCC") {
    inCode = 0x24;
} else if (in == "BCS") {
    inCode = 0x25;
} else if (in == "BEQ") {
    inCode = 0x27;
} else if (in == "BGE") {
    inCode = 0x2C;
} else if (in == "BGT") {
    inCode = 0x2E;
} else if (in == "BHI") {
    inCode = 0x22;
} else if (in == "BHS") {
    inCode = 0x24;
} else if (in == "BLE") {
    inCode = 0x2F;
} else if (in == "BLO") {
    inCode = 0x25;
} else if (in == "BLS") {
    inCode = 0x23;
} else if (in == "BLT") {
    inCode = 0x2D;
} else if (in == "BMI") {
    inCode = 0x2B;
} else if (in == "BNE") {
    inCode = 0x26;
} else if (in == "BPL") {
    inCode = 0x2A;
} else if (in == "BRA") {
    inCode = 0x20;
} else if (in == "BRN") {
    inCode = 0x21;
} else if (in == "BSR") {
    inCode = 0x8D;
} else if (in == "BVC") {
    inCode = 0x28;
} else if (in == "BVS") {
    inCode = 0x29;
} else !opREL
            else {
                Err("Unknown instruction");
                goto end;
            }
            if (op == "") {
                Err("Missing operand");
                goto end;
            }
            bool ok;
            if (op[0].isLetter()) {
                //        -     -       -               -      -     -  FALIJ
            }
            else if (op.startsWith('$')) {
                QString hexValue = op.mid(1);
                if (opCode > 0xFD) {
                    Err("Relative address out of range[-128,127]: " + hexValue);
                    goto end;
                }
                opCode = hexValue.toInt(&ok, 16);
                if (!ok) {
                    Err("Invalid hexadecimal number: " + op);
                    goto end;
                }
            }
            else if (op.startsWith('%')) {
                QString binaryValue = op.mid(1);
                opCode = binaryValue.toInt(&ok, 2);
                if (opCode > 0xFD) {
                    Err("Relative address out of range[-128,127]: " + binaryValue);
                    goto end;
                }
                if (!ok) {
                    Err("Invalid binary number: " + op);
                    goto end;
                }
            }
            else {
                opCode = op.toInt(&ok);
                if (!ok) {
                    Err("Invalid decimal number: " + op);
                    goto end;
                }
                if (opCode < 0)
                    opCode -= 2;
                if (opCode > 127 || opCode < -128) {
                    Err("Relative address out of range[-128,127]: " + QString::number(opCode));
                    goto end;
                }
                qint8 signedValue = static_cast<qint8>(opCode);
                opCode = signedValue & 0xFF;
            }
            qDebug() << opCode;
            Memory[currentAddress] = inCode;
            Memory[currentAddress + 1] = opCode;
            addInstruction(currentAddress, in, op, inCode, opCode);
            currentAddress += 2;
        }
        else if (op.contains(",")) { // IND
            bool ok;
            op.chop(2);
            if (op[0].isLetter()) {
                //        -     -       -               -      -     -  FALIJ
            }else{
                int value = 0; try {int value = getNum(op);} catch (...) { Err("Invalid number: " + op); goto end; }
                if (value>255){
                    Err("Value out of range: " + QString::number(value)); goto end;
                }
                opCode = value;
            }
            PrintConsole(QString::number(opCode),-1);
            if (in == "ADCA") {
    inCode = 0xA9;
} else if (in == "ADCB") {
    inCode = 0xE9;
} else if (in == "ADDA") {
    inCode = 0xAB;
} else if (in == "ADDB") {
    inCode = 0xEB;
} else if (in == "ADDD") {
    inCode = 0xE3;
} else if (in == "ANDA") {
    inCode = 0xA4;
} else if (in == "ANDB") {
    inCode = 0xE4;
} else if (in == "ASL") {
    inCode = 0x68;
} else if (in == "ASR") {
    inCode = 0x67;
} else if (in == "BITA") {
    inCode = 0xA5;
} else if (in == "BITB") {
    inCode = 0xE5;
} else if (in == "CLR") {
    inCode = 0x6F;
} else if (in == "CMPA") {
    inCode = 0xA1;
} else if (in == "CMPB") {
    inCode = 0xE1;
} else if (in == "COM") {
    inCode = 0x63;
} else if (in == "CPX") {
    inCode = 0xAC;
} else if (in == "DEC") {
    inCode = 0x6A;
} else if (in == "EORA") {
    inCode = 0xA8;
} else if (in == "EORB") {
    inCode = 0xE8;
} else if (in == "INC") {
    inCode = 0x6C;
} else if (in == "JMP") {
    inCode = 0x6E;
} else if (in == "JSR") {
    inCode = 0xAD;
} else if (in == "LDAA") {
    inCode = 0xA6;
} else if (in == "LDAB") {
    inCode = 0xE6;
} else if (in == "LDD") {
    inCode = 0xEC;
} else if (in == "LDS") {
    inCode = 0xAE;
} else if (in == "LDX") {
    inCode = 0xEE;
} else if (in == "LSL") {
    inCode = 0x68;
} else if (in == "LSR") {
    inCode = 0x64;
} else if (in == "NEG") {
    inCode = 0x60;
} else if (in == "ORAA") {
    inCode = 0xAA;
} else if (in == "ORAB") {
    inCode = 0xEA;
} else if (in == "ROL") {
    inCode = 0x69;
} else if (in == "ROR") {
    inCode = 0x66;
} else if (in == "SBCA") {
    inCode = 0xA2;
} else if (in == "SBCB") {
    inCode = 0xE2;
} else if (in == "STAA") {
    inCode = 0xA7;
} else if (in == "STAB") {
    inCode = 0xE7;
} else if (in == "STD") {
    inCode = 0xED;
} else if (in == "STS") {
    inCode = 0xAF;
} else if (in == "STX") {
    inCode = 0xEF;
} else if (in == "SUBA") {
    inCode = 0xA0;
} else if (in == "SUBB") {
    inCode = 0xE0;
} else if (in == "SUBD") {
    inCode = 0xA3;
} else if (in == "TST") {
    inCode = 0x6D;
} else !opIND
            else {
                Err("Unknown instruction");
                goto end;
            }
            Memory[currentAddress] = inCode;
            Memory[currentAddress + 1] = opCode;
            addInstruction(currentAddress, in, op, inCode, opCode);
            currentAddress += 2;
        }
        else if (op.startsWith("#")) {
            op = op.mid(1);
            if (op[0].isLetter()) {

            }
            else {
                int value = 0; try {int value = getNum(op);} catch (...) { Err("Invalid number: " + op); goto end; }

                if(takRazInstructions.indexOf(in) != -1){ // TAK RAZ
                    if (value < 0xFFFF){
                        int firstByte = (value >> 8) & 0xFF;
                        int lastByte = value & 0xFF;
                        Memory[currentAddress + 1] = firstByte;
                        Memory[currentAddress + 2] = lastByte;
                        if (in == "ADDD") {
    inCode = 0xC3;
} else if (in == "CPX") {
    inCode = 0x8C;
} else if (in == "LDD") {
    inCode = 0xCC;
} else if (in == "LDS") {
    inCode = 0x8E;
} else if (in == "LDX") {
    inCode = 0xCE;
} else !opTAKRAZ
                        else {
                            Err("Unknown instruction");
                            goto end;
                        }
                        Memory[currentAddress] = inCode;

                        addInstruction(currentAddress, in, op, inCode, value);
                        currentAddress += 3;
                    }else{
                        Err("Value out of range: " + QString::number(value)); goto end;
                    }
                }else{
                    if (value<255){
                        if (in == "ADCA") {
    inCode = 0x89;
} else if (in == "ADCB") {
    inCode = 0xC9;
} else if (in == "ADDA") {
    inCode = 0x8B;
} else if (in == "ADDB") {
    inCode = 0xCB;
} else if (in == "ANDA") {
    inCode = 0x84;
} else if (in == "ANDB") {
    inCode = 0xC4;
} else if (in == "BITA") {
    inCode = 0x85;
} else if (in == "BITB") {
    inCode = 0xC5;
} else if (in == "CMPA") {
    inCode = 0x81;
} else if (in == "CMPB") {
    inCode = 0xC1;
} else if (in == "EORA") {
    inCode = 0x88;
} else if (in == "EORB") {
    inCode = 0xC8;
} else if (in == "LDAA") {
    inCode = 0x86;
} else if (in == "LDAB") {
    inCode = 0xC6;
} else if (in == "ORAA") {
    inCode = 0x8A;
} else if (in == "ORAB") {
    inCode = 0xCA;
} else if (in == "SBCA") {
    inCode = 0x82;
} else if (in == "SBCB") {
    inCode = 0xC2;
} else if (in == "SUBA") {
    inCode = 0x80;
} else if (in == "SUBB") {
    inCode = 0xC0;
} else if (in == "SUBD") {
    inCode = 0x83;
} else !opTAKO
                        else {
                            Err("Unknown instruction");
                            goto end;
                        }
                        Memory[currentAddress] = inCode;
                        Memory[currentAddress + 1] = opCode;
                        addInstruction(currentAddress, in, op, inCode, opCode);
                        currentAddress += 2;
                    }else{
                        Err("Value out of range: " + QString::number(value)); goto end;
                    }
                }

            }
        }
        else if (op[0].isLetterOrNumber()){
            if (operandCallsLabel){

            }else{
                int value = 0; try {int value = getNum(op);} catch (...) { Err("Invalid number: " + op); goto end; }
                if (value<255){
                    if (in == "ADCA") {
    inCode = 0x99;
} else if (in == "ADCB") {
    inCode = 0xD9;
} else if (in == "ADDA") {
    inCode = 0x9B;
} else if (in == "ADDB") {
    inCode = 0xDB;
} else if (in == "ADDD") {
    inCode = 0xD3;
} else if (in == "ANDA") {
    inCode = 0x94;
} else if (in == "ANDB") {
    inCode = 0xD4;
} else if (in == "BITA") {
    inCode = 0x95;
} else if (in == "BITB") {
    inCode = 0xD5;
} else if (in == "CMPA") {
    inCode = 0x91;
} else if (in == "CMPB") {
    inCode = 0xD1;
} else if (in == "CPX") {
    inCode = 0x9C;
} else if (in == "EORA") {
    inCode = 0x98;
} else if (in == "EORB") {
    inCode = 0xD8;
} else if (in == "JSR") {
    inCode = 0x9D;
} else if (in == "LDAA") {
    inCode = 0x96;
} else if (in == "LDAB") {
    inCode = 0xD6;
} else if (in == "LDD") {
    inCode = 0xDC;
} else if (in == "LDS") {
    inCode = 0x9E;
} else if (in == "LDX") {
    inCode = 0xDE;
} else if (in == "ORAA") {
    inCode = 0x9A;
} else if (in == "ORAB") {
    inCode = 0xDA;
} else if (in == "SBCA") {
    inCode = 0x92;
} else if (in == "SBCB") {
    inCode = 0xD2;
} else if (in == "STAA") {
    inCode = 0x97;
} else if (in == "STAB") {
    inCode = 0xD7;
} else if (in == "STD") {
    inCode = 0xDD;
} else if (in == "STS") {
    inCode = 0x9F;
} else if (in == "STX") {
    inCode = 0xDF;
} else if (in == "SUBA") {
    inCode = 0x90;
} else if (in == "SUBB") {
    inCode = 0xD0;
} else if (in == "SUBD") {
    inCode = 0x93;
} else !opDIR
                    else {
                        Err("Unknown instruction");
                        goto end;
                    }
                    Memory[currentAddress] = inCode;
                    Memory[currentAddress + 1] = opCode;
                    addInstruction(currentAddress, in, op, inCode, opCode);
                    currentAddress += 2;
                }else if (value < 0xFFFF){
                    if (in == "ADCA") {
    inCode = 0xB9;
} else if (in == "ADCB") {
    inCode = 0xF9;
} else if (in == "ADDA") {
    inCode = 0xBB;
} else if (in == "ADDB") {
    inCode = 0xFB;
} else if (in == "ADDD") {
    inCode = 0xF3;
} else if (in == "ANDA") {
    inCode = 0xB4;
} else if (in == "ANDB") {
    inCode = 0xF4;
} else if (in == "ASL") {
    inCode = 0x78;
} else if (in == "ASR") {
    inCode = 0x77;
} else if (in == "BITA") {
    inCode = 0xB5;
} else if (in == "BITB") {
    inCode = 0xF5;
} else if (in == "CLR") {
    inCode = 0x7F;
} else if (in == "CMPA") {
    inCode = 0xB1;
} else if (in == "CMPB") {
    inCode = 0xF1;
} else if (in == "COM") {
    inCode = 0x73;
} else if (in == "CPX") {
    inCode = 0xBC;
} else if (in == "DEC") {
    inCode = 0x7A;
} else if (in == "DES") {
    inCode = 0x34;
} else if (in == "DEX") {
    inCode = 0x09;
} else if (in == "EORA") {
    inCode = 0xB8;
} else if (in == "EORB") {
    inCode = 0xF8;
} else if (in == "INC") {
    inCode = 0x7C;
} else if (in == "JMP") {
    inCode = 0x7E;
} else if (in == "JSR") {
    inCode = 0xBD;
} else if (in == "LDAA") {
    inCode = 0xB6;
} else if (in == "LDAB") {
    inCode = 0xF6;
} else if (in == "LDD") {
    inCode = 0xFC;
} else if (in == "LDS") {
    inCode = 0xBE;
} else if (in == "LDX") {
    inCode = 0xFE;
} else if (in == "LSL") {
    inCode = 0x78;
} else if (in == "LSR") {
    inCode = 0x74;
} else if (in == "NEG") {
    inCode = 0x70;
} else if (in == "ORAA") {
    inCode = 0xBA;
} else if (in == "ORAB") {
    inCode = 0xFA;
} else if (in == "ROL") {
    inCode = 0x79;
} else if (in == "ROR") {
    inCode = 0x76;
} else if (in == "SBCA") {
    inCode = 0xB2;
} else if (in == "SBCB") {
    inCode = 0xF2;
} else if (in == "STAA") {
    inCode = 0xB7;
} else if (in == "STAB") {
    inCode = 0xF7;
} else if (in == "STD") {
    inCode = 0xFD;
} else if (in == "STS") {
    inCode = 0xBF;
} else if (in == "STX") {
    inCode = 0xFF;
} else if (in == "SUBA") {
    inCode = 0xB0;
} else if (in == "SUBB") {
    inCode = 0xF0;
} else if (in == "SUBD") {
    inCode = 0xB3;
} else if (in == "TST") {
    inCode = 0x7D;
} else !opRAZ
                    else {
                        Err("Unknown instruction");
                        goto end;
                    }
                    int firstByte = (value >> 8) & 0xFF;
                    int lastByte = value & 0xFF;
                    Memory[currentAddress] = inCode;
                    Memory[currentAddress + 1] = opCode;
                    Memory[currentAddress + 2] = opCode;
                    addInstruction(currentAddress, in, op, inCode, value);
                    currentAddress += 3;
                }else{
                    Err("Value out of range: " + QString::number(value)); goto end;
                }

            }
        }else{
            Err("Really invalid instruction"); goto end;
        }
        skipLine:
            currentLine++;
    }
end:
    updateMemoryTab();
    if (lines.size() != currentLine) {
        QList<QTextEdit::ExtraSelection> linesSelections;
        QList<QTextEdit::ExtraSelection> CodeSelections;
        QTextBlock codeBlock = ui->plainTextCode->document()->findBlockByLineNumber(currentLine);
        QTextBlock linesBlock = ui->plainTextLines->document()->findBlockByLineNumber(currentLine);

        QTextCursor codeCursor(codeBlock);
        codeCursor.select(QTextCursor::LineUnderCursor);
        QTextCursor linesCursor(linesBlock);
        linesCursor.select(QTextCursor::LineUnderCursor);

        QTextCharFormat lineFormat;
        lineFormat.setBackground(Qt::yellow);
        QTextCharFormat charFormat;
        charFormat.setBackground(Qt::red);

        QTextEdit::ExtraSelection linesLineSelection;
        linesLineSelection.format = lineFormat;
        linesLineSelection.cursor = linesCursor;
        linesSelections.append(linesLineSelection);
        ui->plainTextLines->setExtraSelections(linesSelections);

        QTextEdit::ExtraSelection codeLineSelection;
        codeLineSelection.format = lineFormat;
        codeLineSelection.cursor = codeCursor;
        CodeSelections.append(codeLineSelection);

        QTextCursor charCursor(codeBlock);
        charCursor.setPosition(codeBlock.position() + charNum);
        charCursor.setPosition(codeBlock.position() + charNum + 1, QTextCursor::KeepAnchor);

        QTextEdit::ExtraSelection charSelection;
        charSelection.format = charFormat;
        charSelection.cursor = charCursor;

        CodeSelections.append(charSelection);

        ui->plainTextCode->setExtraSelections(CodeSelections);
    }
}

void MainWindow::on_radioButton_clicked()
{
}
